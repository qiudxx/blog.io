<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 分布式事务解决方案下 · qiudx博客</title><meta name="description" content="分布式事务解决方案下 - qiudx"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="https://www.qiudx.top/atom.xml" title="qiudx博客"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="qiudx博客" type="application/atom+xml">
</head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">qiudx博客</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>首页</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>归档</p></a><a href="/about/index.html" target="_self" class="li component-nav-item"><p>关于我</p></a><ul class="shortcut-icons"><a href="https://github.com/qiudxx" target="_blank"><img src="/images/github.svg" class="icon"></a><a href="/atom.xml" target="_blank"><img src="/images/rss.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">分布式事务解决方案下</h1><div class="post-info">Nov 15, 2017</div><div class="post-content"><p><strong>概要</strong></p>
<ul>
<li>柔性事务解决方案概述</li>
<li>可靠消息最终一致性解决方案</li>
<li>最大努力通知性解决方案</li>
<li>TCC</li>
<li>幂等性</li>
</ul>
<a id="more"></a>

<h3 id="柔性事务解决方案概述"><a href="#柔性事务解决方案概述" class="headerlink" title="柔性事务解决方案概述"></a>柔性事务解决方案概述</h3><h4 id="什么是柔性事务"><a href="#什么是柔性事务" class="headerlink" title="什么是柔性事务"></a>什么是柔性事务</h4><p><em>个人理解:</em> <strong>柔性事务可以说是伪事务,柔性事务其实是根据不同的业务场景在业务层使用不同的方法(2pc,事后补偿,消息队列)实现最终一致性</strong></p>
<h3 id="可靠消息最终一致性解决方案"><a href="#可靠消息最终一致性解决方案" class="headerlink" title="可靠消息最终一致性解决方案"></a>可靠消息最终一致性解决方案</h3><p><em>理解:</em> <strong>采取事件机制和消息队列实现分布式事务,来确保消息的最终一致性</strong></p>
<p><img src="/images/%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E6%AD%A3%E5%90%91%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="img"></p>
<p><img src="/images/kekaoxiaoxi.png" alt="img"></p>
<h3 id="最大努力通知性解决方案"><a href="#最大努力通知性解决方案" class="headerlink" title="最大努力通知性解决方案"></a>最大努力通知性解决方案</h3><p><em>理解:</em> <strong>业务主动方完成业务后向业务被动方发送业务通知,允许消息发送失败,当消息发送失败时会按规制重发N次,如果N次后还未收到业务被动方回复则不在发送消息,业务主动方会提供可查询接口供业务被动方查询</strong></p>
<p><img src="/images/%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5.png" alt="img"></p>
<p><strong>行业示例: 银行通知,商户通知</strong></p>
<h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h3><p><em>理解:</em> TCC实际是将一个整体事务拆分为一个个小事务(本地事务),每个事务见互不干扰</p>
<ul>
<li>Try：预留业务资源</li>
<li>Confirm：确认执行业务操作</li>
<li>Cancel：取消执行业务操作</li>
</ul>
<h4 id="一个完整的TCC事务参与方包括三部分"><a href="#一个完整的TCC事务参与方包括三部分" class="headerlink" title="一个完整的TCC事务参与方包括三部分"></a>一个完整的TCC事务参与方包括三部分</h4><ul>
<li>主业务服务：主业务服务为整个业务活动的发起方。</li>
<li>从业务服务：从业务服务负责提供TCC业务操作，是整个业务活动的操作方。从业务服务必须实现Try、Confirm和Cancel三个接口，供主业务服务调用。</li>
<li>业务活动管理器(框架内部)：业务活动管理器管理控制整个业务活动，包括记录维护TCC全局事务的事务状态和每个从业务服务的子事务状态，并在业务活动提交时确认所有的TCC型操作的confirm操作，在业务活动取消时调用所有TCC型操作的cancel操作。</li>
</ul>
<h4 id="TCC的优点和限制"><a href="#TCC的优点和限制" class="headerlink" title="TCC的优点和限制"></a>TCC的优点和限制</h4><ul>
<li>TCC事务的优点:<ul>
<li>解决了跨应用业务操作的原子性问题，在诸如组合支付、账务拆分场景非常实用。</li>
<li>TCC实际上把数据库层的二阶段提交上提到了应用层来实现，对于数据库来说是一阶段提交，规避了数据库层的2PC性能低下问题。</li>
</ul>
</li>
<li>TCC事务的缺点<ul>
<li>TCC的Try、Confirm和Cancel操作功能需业务提供，开发成本高。</li>
</ul>
</li>
</ul>
<h4 id="案例理解-三个不同分库的帐户A、B、C，A和B一起向C转帐共80元"><a href="#案例理解-三个不同分库的帐户A、B、C，A和B一起向C转帐共80元" class="headerlink" title="案例理解(三个不同分库的帐户A、B、C，A和B一起向C转帐共80元)"></a>案例理解(三个不同分库的帐户A、B、C，A和B一起向C转帐共80元)</h4><ol>
<li>Try：尝试执行业务。<br>完成所有业务检查(一致性)：检查A、B、C的帐户状态是否正常，帐户A的余额是否不少于30元，帐户B的余额是否不少于50元。预留必须业务资源(准隔离性)：帐户A的冻结金额增加30元，帐户B的冻结金额增加50元，这样就保证不会出现其他并发进程扣减了这两个帐户的余额而导致在后续的真正转帐操作过程中，帐户A和B的可用余额不够的情况。</li>
<li>Confirm：确认执行业务。<br>真正执行业务：如果Try阶段帐户A、B、C状态正常，且帐户A、B余额够用，则执行帐户A给账户C转账30元、帐户B给账户C转账50元的转帐操作。不做任何业务检查：这时已经不需要做业务检查，Try阶段已经完成了业务检查。只使用Try阶段预留的业务资源：只需要使用Try阶段帐户A和帐户B冻结的金额即可。</li>
<li>Cancel：取消执行业务<br>释放Try阶段预留的业务资源：如果Try阶段部分成功，比如帐户A的余额够用，且冻结相应金额成功，帐户B的余额不够而冻结失败，则需要对帐户A做Cancel操作，将帐户A被冻结的金额解冻掉。</li>
</ol>
<h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><ul>
<li>简单的说, 业务操作支持重试, 不会产生不利影响. 常见的实现方式: 为消息额外增加唯一ID.根据业务状态判断</li>
</ul>
</div></article></div></div></main><footer class="footer-container"><div class="paginator"><a href="/2017/11/16/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="prev">PREV</a><a href="/2017/11/14/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%8A/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2019 <a href="https://www.qiudx.top">qiudx</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer></body></html>