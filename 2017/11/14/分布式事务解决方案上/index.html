<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 分布式事务解决方案上 · qiudx's blog</title><meta name="description" content="分布式事务解决方案上 - qiudx"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="https://www.qiudx.top/atom.xml" title="qiudx's blog"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="qiudx's blog" type="application/atom+xml">
</head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">qiudx's blog</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>首页</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>归档</p></a><a href="/about" target="_self" class="li component-nav-item"><p>关于我</p></a><ul class="shortcut-icons"><a href="https://github.com/qiudxx" target="_blank"><img src="/images/github.svg" class="icon"></a><a href="/atom.xml" target="_blank"><img src="/images/rss.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">分布式事务解决方案上</h1><div class="post-info">Nov 14, 2017</div><div class="post-content"><p><strong>概要</strong></p>
<ul>
<li>事务</li>
<li>BSAE理论</li>
<li>CAP理论</li>
<li>全局事务介绍</li>
</ul>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><a id="more"></a>
<h5 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h5><ul>
<li>事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所做的所有更改都会被撤消</li>
</ul>
<h5 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h5><ul>
<li>一致性<ul>
<li>事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。事务结束时，所有的内部数据结构都必须是正确的。</li>
</ul>
</li>
<li>原子性<ul>
<li>事务必须是原子工作单元。对于其数据修改，要么全都执行，要么全都不执行。</li>
</ul>
</li>
<li>持久性<ul>
<li>事务完成之后，它对于系统的影响是永久性的。该修改即使出现系统故障也将一直保持。</li>
</ul>
</li>
<li>隔离性<ul>
<li>由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务识别数据时数据所处的状态，或者是另一个并发事务修改它之前的状态，或者是第二个事务修改它之后的状态，事务不会识别中间状态的数据。这称为可串行性，因为它能够重新装载起始数据，并且重播一系列事务，以使数据结束时的状态与原始事务执行的状态相同。</li>
</ul>
</li>
</ul>
<h5 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h5><ul>
<li>自动提交事务：每条单独的语句都是一个事务。</li>
<li>显式事务：每个事务均以BEGIN TRANSACTION语句显式开始，以COMMIT或ROLLBACK语句显式结束。</li>
<li>隐性事务：在上个事务完成时新事务隐式启动，但每个事务仍以COMMIT或ROLLBACK语句显式完成。</li>
</ul>
<h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><ul>
<li><p>BA: 基本业务可用性,支持分区失败(允许部分服务异常)</p>
<ul>
<li>响应时间上的损失。正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒</li>
<li>系统功能上的损失。正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面</li>
</ul>
</li>
<li><p>S: 柔性状态(软状态)</p>
<ul>
<li>软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时</li>
</ul>
</li>
<li><p>E: 最终一致性</p>
<ul>
<li>最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</li>
</ul>
</li>
<li><p><strong>核心思想:</strong></p>
<ul>
<li>即使无法做到强一致性，那么每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性</li>
<li>原子性和持久性必须保证,只有适当降低<em>一致性<em>和</em>隔离性</em></li>
</ul>
</li>
</ul>
<h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><ul>
<li><p>C: 一致性 all nodes see the same data at the same time</p>
</li>
<li><p>A: 原子性 Reads and writes always succeed</p>
</li>
<li><p>P:分区容错性 the system continues to operate despite arbitrary message loss or failure of part of the system</p>
<p><img src="/images/cap.png" alt="image"></p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">选择</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CA</td>
<td align="left">降低分区容错性,加强一致性和可用性,其实就是传统的单机数据库的选择</td>
</tr>
<tr>
<td align="left">AP</td>
<td align="left">降低一致性(这里说的一致性是指强一致性),加强分区容错性和可用性,现在很多分布式系统都是这么设计的,例如eureka</td>
</tr>
<tr>
<td align="left">CP</td>
<td align="left">降低可用性,追求一致性和分容错性,基本不会选择,如果网络出现问题会导致系统不可用,例如zookeeper</td>
</tr>
</tbody></table>
<p>  <strong>分布式系统中,分区容错性是一个最基本的要求。因为分布式系统中组件必须被部署在不同的节点上,因而服务间必须跨网络调用。对于分布式系统而言网络问题是必然会出现的,因此分区容错就成了每一个分布式系统中绕不去的坎,往往架构师们都在一致性和可用性中寻求平衡点</strong></p>
<h3 id="常见的分布式解决方案"><a href="#常见的分布式解决方案" class="headerlink" title="常见的分布式解决方案"></a>常见的分布式解决方案</h3><h4 id="刚性事务解决方案"><a href="#刚性事务解决方案" class="headerlink" title="刚性事务解决方案"></a>刚性事务解决方案</h4><ul>
<li><p>标准的分布式解决方案(全局事务)</p>
<p><img src="/images/%E6%A0%87%E5%87%86%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.png" alt="img"></p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">优缺点</th>
<th align="left">分析</th>
</tr>
</thead>
<tbody><tr>
<td align="left">优点</td>
<td align="left">严格的ACID</td>
</tr>
<tr>
<td align="left">缺点</td>
<td align="left">1. 效率非常的低,在全局事务方式下,全局事务管理器TM通过XA接口使用两阶段提交协议(2pc)与资源层(数据 库)交互时,数据被锁定的时间跨越了整个事务,直到全局事务结束  2.   业务规模越来越大时,2pc局限性越明显,系统可伸缩性会很差  3. XA协议系统开销大,只有支持XA协议的资源才能参与分布式事务</td>
</tr>
</tbody></table>
<p>  <strong>分布式系统中很少采取这种方案,刚性事务力度大,时间长,效率低.下节将介绍柔性事务解决方案</strong></p>
</div></article></div></div></main><footer class="footer-container"><div class="paginator"><a href="/2017/11/15/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%8B/" class="prev">PREV</a><a href="/2017/11/14/%E6%95%B0%E7%BB%84/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2019 <a href="https://www.qiudx.top">qiudx</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer></body></html>